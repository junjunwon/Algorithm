# 출처 : 동빈나 유튜브 강의
- https://www.youtube.com/watch?v=m-9pAwq1o3w&list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC
- 
## 알고리즘 설계 팁!
일반적으로 CPU 기반의 개인 컴퓨터나 채점용 컴퓨터에서 연산 횟수가 5억을 넘어가는 경우
- C언어를 기준으로 통상 1-3초 가량 소요
- Python을 기준으로 통상 5-15초 가량의 시간 소요
  - PyPy의 경우 때때로 C언어보다 빠르게 동작하기도 하기 때문에 시험에 PyPy를 지원하는 경우 꼭 PyPy로 제출하면 시간복잡도 측면에서 유리하다. (python보다 빠르다고 보장하진 않고, 메모리를 더 사용할 수도 있다. )
    - 일반적으로 python으로 제출한 뒤 시간초과가 날 경우 pypy로 제출
    - pypy로 제출했는데 메모리 초과가 날 경우 python으로 제출
- O(N의 세제곱)의 알고리즘을 설계한 경우, N의 값이 5,000이 넘는다면 얼마나 걸릴까??
  - 5천을 세번 곱하면 1250억이 연산횟수
    - 파이선이 1초에 약 5천만번 계산을 할 경우 약 2500초 정도가 1250억을 연산하는데 걸린다. 
    - 수행시간을 예측해서 알고리즘을 설계하는 것이 중요하다.
  - **채점용 서버에서는 파이선이 1초에 약 2천만번정도의 연산만 처리할 수 있다고 가정하고 문제에 접근하는 것이 팁!**
  - 코딩테스트 문제 수행시간 제한은 **1-5초**정도로 제한
    - 시간이 명시되어 있지 않을 경우 5초정도라 생각하면 된다.
  - **시간제한 수행 계산하기**
    - 시간제한이 1초인 문제를 만났을때 일반적인 기준
      - N의 범위가 500인 경우 : 시간 복잡도가 O(N의 세제곱)인 알고리즘을 설계하면 SOLVE!
      - N의 범위가 2,000인 경우 : 시간 복잡도가 O(N의 제곱)인 알고리즘을 설계하면 SOLVE!
      - N의 범위가 100,000인 경우 : 시간 복잡도가 O(NlogN)인 알고리즘을 설계하면 SOLVE!
      - N의 범위가 10,000,000인 경우 : 시간 복잡도가 O(N의 제곱)인 알고리즘을 설계하면 SOLVE!

## 알고리즘 문제 해결 과정
- 지문 읽기 및 컴퓨터적 사고
  - 문제를 잘게 분해해보자.(단계별로)
- 요구사항(복잡도) 분석
  - 어느 정도 성능으로 정답판정을 받을 수 있는지.
- 문제 해결을 위한 아이디어 찾기
- 소스코드 설계 및 코딩
* 일반적으로 대부분의 문제 출제자들은 핵심 아이디어를 캐치한다면 간결하게 소스코드를 작성할 수 있는 형태로 문제를 출제한다.

## 지수 표현 방식
- 파이썬에서는 e나 E를 이용한 지수 표현 방식을 이용할 수 있다.
  - e나 E다음에 오는 수는 10의 지수부를 의미한다.
  - 예를 들어 1e9를 입력할 경우 10의 9제곱(1,000,000,000 = 10억)이 된다.
- 지수 표현 방식은 임의의 큰 수를 위해 자주 사용 (실수형 변수에서 사용)
- 최단 경로 알고리즘에서는 도달할 수 없는 노드에 대하여 최단 거리를 무한(INF)로 설정하곤 한다.
- 이때 가능한 최대값이 10억 미만이라면 무한(INF)의 값으로 1e9를 이용할 수 있다.


## 실수형
- IEEE754표준에서는 실수형을 저장하기 위해 4바이트 혹은 8바이트의 고정된 크기의 메모리를 할당하여 컴퓨터 시스템은 실수 정보를 표현하는 정확도에 한계를 가진다.
- 예를 들어 10진수 체계에서는 0.3과 0.6을 더한 값이 0.9로 정확히 떨어진다.
  - 하지만 2진수에서는 0.9를 정확히 표현할 수 있는 방법이 없다.
  - 컴퓨터는 최대한 0.9와 가깝게 표현하지만, 미세한 오차가 발생하게 된다.
- 해결 법
  - round()를 이용
    - 123.456을 소수 셋째 자리에서 반올림하려면 round(123.456, 2)라고 작성한다.
      - 결과는 123.46

## 수 자료형 연산
- 사칙연산과 나머지 연산이 많이 사용된다.
- 단 나누기 연산자(/)를 주의해서 사용해야 한다.
  - 자바, C와 달리 파이썬에서 나누기 연산자(/)는 나눠진 결과를 **실수형**으로 반환한다.
- 다양한 로직을 설계할 때 나머지 연산자(%)를 이용할 때가 많다.
  - a가 홀수인지 체크할 경우
- 파이썬에서는 몫을 얻기 위해 몫 연산자(//)를 사용한다.
- 이 외에도 거듭 제곱 연산자(**) 등등이 있다.
- Python은 기본적으로 제공하는 연산자가 있다.

## 리스트 자료형
- 여러개의 데이터를 연속적으로 담아 처리하기 위해 사용하는 자료형(연결리스트와도 유사한 기능을 제공한다.)
- append 제거, 뒤쪽에서 원소를 제거하는 기능 제거
- 리스트 대신에 배열 혹은 테이블이라고도 한다.
- C++의 STL vector와 기능적으로 유사한다.
- 리스트 초기화
  - 리스트는 대괄호([])안에 원소를 넣어 초기화하며, 쉼표(,)로 원소를 구분한다.
  - 비어 있는 리스트를 선언하고자 할 때는 list() 혹은 간단히 []를 이용할 수 있다.
  - 리스트의 원소에 접근할 때는 인덱스(index)값을 괄호에 넣는다.
    - **인덱스는 0부터 시작**
- 리스트의 인덱싱과 슬라이싱
  - 인덱스 값을 입력하여 리스트의 특정한 원소에 접근하는 것을 **인덱싱(Indexing)**이라고 한다.
  - 파이썬의 인덱스 값은 양의 정수와 음의 정수를 모두 사용한다.
  **- 음의 정수를 넣으면 원소를 거꾸로 탐색!**
  - 리스트에서 연속적인 위치를 갖는 원소들을 가져와야 할 때는 **슬라이싱(Slicing)**을 이용한다.
    - 대괄호 안에 콜론(:)을 넣어서 시작 인덱스와 끝 인덱스를 설정할 수 있다.
      **- 끝 인덱스는 실제 인덱스보다 1을 더 크게 설정한다.**
**리스트 컴프리헨션 (아주 강력한 방식!)**
  - 리스트를 초기화하는 방법 중 하나
  - 대괄호 안에 조건문과 반복문을 적용하여 리스트를 초기화할 수 있다.
  - **2차원 리스트를 초기화할 때 효과적**으로 사용된다.
  - 특히 N * M 크기의 2차원 리스트를 한 번에 초기화 해야 할 때 매우 유용하다
    - 좋은 예시 : array = [[0] * m for _ in range(n)]
  - 만약 2차원 리스트를 초기화할 때 다음과 같이 작성하면 예기치 않은 결과가 나올 수 있다.
    - 잘못된 예시 : array = [[0] * m] * n
      - 파이썬은 기본적으로 리스트 자료형을 이용해 변수값을 할당하게 되면 내부적으로 그 리스트는 객체형태로 처리가 된다. -> 별도의 주소값을 가지게 된다.
        - 단순히 리스트 객체 자체를 n번 곲하게 되면 단순하게 내부적으로 길이가 m인 리스트를 n번만큼 참조값을 복사하는 것과 같으므로 이 경우 내부적으로 포함되있는 리스트가 모두 동일한 객체, 즉 모든 같은 객체로써 인식될 수 있다. 
          - 이렇게 초기화할 경우 내부적인 리스트는 모두 같은 리스트로서 처리되기 대문에 내부 리스트 중에 특정 위치의 하나의 값만 바꿔도 모든 리스트에 동일하게 그 변경 사항이 변경될 수 있으므로 예기치 못한 결과를 얻을 수 있다.

### 언더바는 언제 사용하는가?
- 파이썬에서 반복을 수행하되 반복을 위한 변수의 값을 무시하고자 할때 언더바를 사용한다.

###  코딩 테스트에서 자주 사용하는 리스트 관련 기타 메서드
- append()
  - 변수명.append()
  - 리스트에 원소를 하나 삽입할 때 사용한다.
  - 시간복잡도 : O(1)
- sort()
  - 변수명.sort()
    - 기본 정렬 기능으로 오름차순으로 정렬한다.
  - 변수명.sort(reverse=True)
    - 내림차순으로 정렬한다.
  - 시간 복잡도 : O(NlogN)
- reverse()
  - 변수명.reverse()
    - 리스트의 원소의 순서를 모두 뒤집어 놓는다.
    - 시간 복잡도 : O(N)
- insert()
  - insert(삽입할 위치 인덱스, 삽입할 값)
    - 특정한 인덱스 위치에 원소를 삽입할 때 사용한다.
  - 시간 복잡도 : O(N)
- count()
  - 변수명.count(특정 값)
    - 리스트에서 특정한 값을 가지는 데이터의 개수를 셀 때 사용한다.
    - 시간 복잡도 : O(N)
- remove()
  - 변수명.remove(특정 값)
  - 특정한 값을 갖는 원소를 제거하는데 값을 가진 원소가 여러 개면 하나만 제거한다.)
  - 시간 복잡도 : O(N)
  - 특이점 : 파이썬은 removeAll 함수를 제공하지 않기 때문에 따로 함수를 작성해줘야 한다.

## 문자열 자료형
- 문자열 변수를 초기화할때 -> 큰따옴표(")나 작은 따옴표(')를 이용한다.
- 전체 문자열 큰따옴표 -> 내부는 작은 따옴표
- 전체 문자열 작은 따옴표 -> 내부는 큰 따옴표
- 백슬래시(\)를 사용할 경우 큰 따옴표나 작은 따옴표를 원하는만큼 포함 가능.
- 덧셈 / 곱셈 연산
  - 덕셈 : 문자열이 더해져서 연결된다.
  - 특정한 양의 정수와 곱할 경우 문자열이 그 값만큼 여러 번 더해진다.
  - 문자열도 인덱싱 / 슬라이싱 사용 가능
    **- 다만 문자열은 특정 인덱스의 값을 변경할 수 없다 (Immutable)**


## 튜플 자료형 (특이!)
- 튜플은 한 번 선언된 값을 변경할 수 없다.
- 리스트는 대괄호([])를 이용하지만 튜플은 소괄호(())를 이용한다.
- 튜플은 리스트에 비해 상대적으로 공간 효율적이다.
### 튜플을 사용하면 좋은 경우
- 서로 다른 성질의 데이터를 묶어서 관리해야 할때
  - 최단 경로 알고리즘에서는 (비용, 노드 번호)의 형태로 튜플 자료형을 자주 사용한다.
- 데이터의 나열을 해싱(Hashing)의 키 값으로 사용해야 할때
  - 튜플은 변경이 불가능하므로 리스트와 다르게 키 값으로 사용될 수 있다.
- 리스트보다 메모리를 효율적으로 사용해야 할때

## 사전 자료형
- 사전 자료형은 키(Key)와 값(Value)의 쌍을 데이터로 가지는 자료형이다.
  - 앞서 다루었던 리스트나 튜플이 값을 순차적으로 저장하는 것과는 대비도니다.
- 사전 자료형은 키와 값의 쌍을 데이터로 가지며 원하는 변경 불가능한(Immutable) 자료형을 키로 사용할 수 있다.
- 파이썬의 사전 자료형은 해시 테이블(Hash Table)을 이용하므로 데이터의 조회 및 수정에 있어서 O(1)의 시간에 처리할 수 있다.

## 집합 자료형
- 수학적으로 집합의 특징
  - 중복을 허용하지 않는다.
  - 순서가 없다.
- 존재 여부 확인할대 효과적이다.
- 집합은 리스트 혹은 문자열을 이용해서 초기화할 수 있다.
  - 이때 set() 함수를 이용한다.
- 혹은 중괄호({}) 안에 각 원소를 콤마(,)를 기준으로 구분하여 삽입함으로써 초기화할 수 있다.
- 데이터의 조회 및 수정에 있어서 O(1)의 시간에 처리할 수 있다.
- 집합 연산
  - 합집합(|) / 교집합(&) / 차집합(-)


